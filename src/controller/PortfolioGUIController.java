package controller;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import java.util.Map;
import javax.swing.JTextField;
import model.FlexiblePortfolioInterface;
import model.StockInterface;
import model.Strategy;
import view.PortfolioGUIView;
import view.StockGUIView;

/**
 * This is a controller specifically designed to handle the interactions between the portfolio GUI
 * view and the portfolio model. It listens for user actions performed in the GUI and updates the
 * model or the view accordingly.
 */
public class PortfolioGUIController extends AbstractController implements ActionListener {

  private final FlexiblePortfolioInterface portfolio;

  private final PortfolioGUIView view;

  /**
   * Constructs a PortfolioGUIController with references to the portfolio model and the
   * portfolio view.
   * This setup facilitates communication between the model and the view.
   *
   * @param portfolio the model that holds the portfolio data
   * @param view      the view that displays the portfolio data to the user
   */
  public PortfolioGUIController(FlexiblePortfolioInterface portfolio, PortfolioGUIView view) {
    this.portfolio = portfolio;
    this.view = view;
  }

  /**
   * Initializes the main menu by setting this controller as the action listener for GUI events
   * and making the view visible. This method prepares the user interface for interaction.
   */
  public void mainMenu() {
    this.view.setButtonListener(this);
    this.view.makeVisible();
  }

  /**
   * Handles action events generated by the user interface. Depending on the user's action,
   * it performs operations such as buying or selling stocks, displaying portfolio composition,
   * calculating the portfolio's value or cost basis, and inspecting individual stocks.
   *
   * @param e the action event that occurred in the user interface
   */
  @Override
  public void actionPerformed(ActionEvent e) {
    String[] stockList = portfolio.listStocks().toArray(new String[0]);
    System.out.println(portfolio.listStocks());
    System.out.println(stockList);
    String date = view.getDate();
    String buyDate = view.getBuyDate();
    String stock = view.getQuantity();
    switch (e.getActionCommand()) {
      case "Buy Stock":
        if ("".equals(buyDate)) {
          view.displayMessage("Enter a Date");
        } else if (checkDate(buyDate)) {
          try {
            int quantity = Integer.parseInt(stock);
            view.displayMessage(portfolio.buyExisting(view.getStockSymbol() + 1,
                    buyDate, quantity));
          } catch (NumberFormatException msg) {
            view.displayMessage("Invalid Quantity");
          }
        } else {
          view.displayMessage("Enter Valid Date");
        }
        break;
      case "Rebalance Portfolio":
        date = view.getRebalanceDate();
        if (!checkDate(date)) {
          view.displayMessage("Enter a valid date in YYYY-MM-DD format");
          return;
        }
        try {
          Map<String, Float> targetWeights = new HashMap<>();
          for (Map.Entry<String, JTextField> entry : view.getStockWeights().entrySet()) {
            float weight = Float.parseFloat(entry.getValue().getText()); // Convert percentage to decimal
            targetWeights.put(entry.getKey(), weight);
          }
           portfolio.rebalance(date, targetWeights);
          view.displayMessage("successfully rebalanced portfolio");
        } catch (NumberFormatException ex) {
          view.displayMessage("Invalid weight format");
        } catch (Exception ex) {
          view.displayMessage("Failed to rebalance portfolio: " + ex.getMessage());
        }
        break;

      case "Sell Stock":
        if ("".equals(buyDate)) {
          view.displayMessage("Enter a Date");
        } else if (checkDate(buyDate)) {
          try {
            int quantity = Integer.parseInt(stock);
            view.displayMessage(portfolio.sellExisting(view.getStockSymbol() + 1,
                    buyDate, quantity));
          } catch (NumberFormatException msg) {
            view.displayMessage("Invalid Quantity");
          }
        } else {
          view.displayMessage("Enter Valid Date");
        }
        break;
      case "Composition":
        view.displayMessage(portfolio.composition());
        break;
      case "Value":
        if (date.isEmpty()) {
          view.displayMessage("Enter a Date");
        } else if (checkDate(date)) {
          view.displayMessage(portfolio.value(date));
        } else {
          view.displayMessage("Enter Valid Date");
        }
        break;
      case "Cost Basis":
        if (date.isEmpty()) {
          view.displayMessage("Enter a Date");
        } else if (checkDate(date)) {
          view.displayMessage(portfolio.costBasis(date));
        } else {
          view.displayMessage("Enter Valid Date");
        }
        break;
      case "Inspect Stock":
        int num = view.getStockOption();
        try {
          StockInterface stockModel = portfolio.inspectStock(num + 1);
          StockGUIView stockView = new StockGUIView(stockList[num]);
          StockGUIController controller = new StockGUIController(stockModel, stockView);
          controller.mainMenu();
        } catch (Exception ex) {
          throw new RuntimeException(ex);
        }
        break;
      case "Save DAC Portfolio":
        try {
          int amountDAC = Integer.parseInt(view.getAmounts("DAC"));
          if (amountDAC < 0) {
            throw new Exception("Illegal Amount");
          }
          // try catch in create portfolio, invalid throws error
          List<String> dates = view.getDates("DAC");
          List<String> percentages = view.getPercents("DAC");
          if (validateInputs(dates, percentages)) {
            List<Integer> percents = new ArrayList<>();
            for (String numPercent : percentages) {
              percents.add(Integer.parseInt(numPercent));
            }
            if (percents.stream().reduce(0, Integer::sum) == 100) {
              StringBuilder result = new StringBuilder();
              for (int i = 0; i < percents.size(); i++) {
                result.append(portfolio.buyExistingPrice(i, dates.get(i),
                        (float) (amountDAC / 100) * Integer.parseInt(percentages.get(i))))
                        .append("\n");
              }
              view.displayMessage(String.valueOf(result));
              view.removeFields();
            } else {
              view.displayMessage("Percentages do not add upto 100");
              view.removeFields();
            }
          } else {
            view.displayMessage("Invalid Inputs in Stock Date or Percentage");
            view.removeFields();
          }
        } catch (NumberFormatException msg) {
          view.displayMessage("Invalid Amount");
        } catch (Exception msg) {
          view.displayMessage(msg.getMessage());
          view.removeFields();
        }
        view.removeFields();
        break;
      case "Save Strategy Portfolio":
        try {
          int amountStrat = Integer.parseInt(view.getAmounts("Strat"));
          if (amountStrat < 0) {
            throw new Exception("Illegal Amount");
          }
          int period = Integer.parseInt(view.getPeriod());
          if (period < 1) {
            throw new Exception("Illegal Period");
          }
          // try catch in create portfolio, invalid throws error
          List<String> dates = view.getDates("Strat");
          List<String> percentages = view.getPercents("Strat");
          List<String> date1 = new ArrayList<>();
          date1.add(dates.get(0));
          if (dates.get(1).equals("")) {
            dates.set(1, "1");
          } else {
            SimpleDateFormat parser = new SimpleDateFormat("yyyy-MM-dd");
            parser.setLenient(false);
            try {
              parser.parse(dates.get(1));
            } catch (Exception msg) {
              view.displayMessage("Invalid End Date");
              view.removeFields();
            }
          }
          if (validateInputs(date1, percentages)) {
            List<Integer> percents = new ArrayList<>();
            StringBuilder result = new StringBuilder();
            for (String num1 : percentages) {
              percents.add(Integer.parseInt(num1));
            }
            if (percents.stream().reduce(0, Integer::sum) == 100) {
              List<Float> prices = new ArrayList<>();
              for (int i = 0; i < percents.size(); i++) {
                prices.add((float) (amountStrat / 100) * percents.get(i));
              }
              Strategy strategy = new Strategy(dates.get(0), dates.get(1), period,
                      portfolio.listStocks(), prices);
              String name = view.getName();
              name = name.replace(name.substring(name.length() - 4), "");
              strategy.saveStrategy(name);
              for (int i = 0; i < percents.size(); i++) {
                result.append(
                portfolio.buyExistingPrice(i, dates.get(0), prices.get(i))).append("\n");
              }
              view.displayMessage(String.valueOf(result));
              view.removeFields();
            } else {
              view.displayMessage("Percentages do not add upto 100");
              view.removeFields();
            }
          } else {
            view.displayMessage("Invalid Inputs in Stock Symbol, Date or Percentage");
            view.removeFields();
          }
        } catch (NumberFormatException msg) {
          view.displayMessage("Invalid Amount or Period");
        } catch (Exception msg) {
          view.displayMessage(msg.getMessage());
          view.removeFields();
        }
        view.removeFields();
        break;
      default:
        break;
    }
  }

  private boolean validateInputs(List<String> dates, List<String> quantities) {
    try {
      for (String quantity : quantities) {
        if (Integer.parseInt(quantity) < 0) {
          return false;
        }
      }
    } catch (NumberFormatException e) {
      return false;
    }
    for (String date : dates) {
      if (!checkDate(date)) {
        return false;
      }
    }
    return true;
  }
}
